2019. 01. 15

GRAPH
- 두 정점 사이에 간선이 여러개이면 최단경로를 구할 때 작은거만 저장해주면 됨
- 방향 그래프의 경우 In-degree, Out-degree로 나누어서 차수를 계산
- 그래프 문제를 풀 땐 정점과 간선을 모두 저장하여야 함
- 인접행렬로 나타내면 공간은 V^2, 시간은 O(V) -> 거의 사용하지 않음(비효율적)
- 인접리스트 사용. 원래는 링크드리스트를 사용하지만 동적배열 사용해도됨.
  => C++는 vector, java는 arraylist, python은 [] 사용
  공간은 E, 시간은 O(차수)
- 간선리스트는 1차원 배열에 모든 간선을 각각 저장 후 간선을 정렬.
  벡터를 사용하지 못하면 사용.
  
그래프의 탐색
- DFS: 깊이우선(Depth), 스택 사용
- BFS: 너비우선(Breadthe), 큐 사용
  => 브루트포스와 차이점은 한 번씩 쭉 들리면 끝난다는 것

연결요소
- 한 개의 그래프에서, 여러개의 그래프처럼 이어지지 않은 그래프를 각각 연결 요소라고 함

이분 그래프
- 사람이 문제를 풀면 사람과 문제 사이에만 간선이 존재. 즉, 사람과 그래프 둘로 나뉘므로 이분 그래프

단지번호 붙이기(2667번)
- 연결요소 찾기 문제
- 인접행렬, 인접리스트를 굳이 만들 필요 없음
- dx = [0, 0, 1, -1]
  dy = [1, -1, 0, 0] 으로 방향을 저장해줌
  
BFS
- 최소 비용 문제 해결 가능
- 간선의 가중치가 1이여야 함
- C++의 경우 pair<type, type>을 사용해서 두 가지 정보를 하나에 담을 수 있다.
- 그 이상일 땐 tuple 사용
- 파이썬은 deque을 사용

숨바꼭질(1697번)
DSLR(9019번)
이모티콘(14226번)
- ctrlC, ctrlV, backspace 연산
- (S, C)라고 가정할 떄, 각각 (S, S), (S + C, C), (S - 1, C)가 됨


Brute Force
리모컨
- 중복되면 안되고(+, -, - 등)
- 쓸데없는 짓을 하면 안됨(540, +, +, 5403, +, +)
