2019. 01. 17

Brute Force - 순열
- 순열을 사전순으로 나열했을 때, 사전순으로 다음에 오는 순열과 이전에 오는 순열 찾기
  => C++의 algorithm에는 이미 next_permutation과 prev_permutation이 존재하기 때문에 사용하면 됨
     Python의 itertools에도 next_permutation 존재
- 어떤 순열의 마지막 순열을 구하면, 그 다음 순열을 구할 수 있다.
ex) 7 2 3 6 5 3 1의 경우 7 2 3 / 6 5 4 1이라는 순열의 마지막 순열임을 알 수 있음.
    3 다음으로 뒤에서 큰 수는 4이므로, 위치를 바꾸면 7 2 4 / 6 5 3 1 이고, 뒷자리를 뒤집으면
    바로 다음 순열인 7 2 4 / 1 3 5 6 이 됨.
- 모든 순열을 구하는 시간: O(N * N!)
  => 따라서, 시간 상 순열을 전부 구해야하는 문제면 N이 10이하로 주어질 것임
- 순열 문제에선 do-while을 많이 사용.

외판원 순회2
- 영어로 Travelling Salesman Problem(TSP)
- 모든 도시를 방문하면서 한 번 방문한 도시는 다시 가지 않으므로 순열문제!
- 따라서 N <= 10 이어야 풀 수 있음


Brute Force - 재귀
1, 2, 3 더하기
- 정답을 찾은 경우 (sum == goal, 1 리턴),
  불가능 한 경우(sum > goal, 0 리턴),
  다음 경우 호출
  1을 사용: go(count + 1, sum + 1, goal)
  2를 사용: go(count + 1, sum + 2, goal)
  3을 사용: go(count + 1, sum + 3, goal) -> 세 수 합 리턴        이 필요.
- DP로 푸는게 사실 더 좋음. O(3^N) DP로는 O(N)

  
