2019. 01. 10 목요일

Mathematics
- 소수를 사용하는건 최대한 지양하자.
- 만약 써야한다면 double 자료형 사용. float은 덜 정확

- (6%3 ‒ 5%3) % 3 = (0 ‒ 2) % 3 = -2 % 3 = ?에서 C++의 경우 -2를 출력함
따라서, ((6%3 ‒ 5%3) + 3) % 3 을 하면 됨. (양수인지 음수인지 모르면 분모를 더하기)

- 최대공약수(GCD)를 구할 때, 
a를 b로 나눈 나머지를 r이라고 하면 GCD(a, b) = GCD(b, r) - 유클리드 호제법
재귀로 풀어내면 O(logN)의 시간복잡도를 가진다.
-> 분수의 형태로 나와 약분을 할 때나 진짜 수학문제를 풀 때 사용함.

- 최소공배수(LCM)을 구할 때,
GCD * LCM = A * B 인것을 활용하면 됨.

- 소수를 구하는 문제
1. 어떤 수 x가 소수?
  // 정의를 활용한 방법
  bool prime(int n) {
    if (n < 2) {
      return false;
    }
    for (int i = 2; i <= n - 1; i++) {
      if (n % i == 0) {
        return false;
      }
    }
    return true;
  }
-> 정의 + 범위 쪼개기, 즉 i <= n/2; 로 해도 좋다.
-> 더 나아가면 i < =sqrt(n) -> i * i <= n; 으로 가는게 더 좋다. 이유는 자명함...

2. 1~N 범위의 모든 소수?
  1.의 방법을 활용하면 O(n*sqrt(n))

  -> 더 나은방법? 에라토스테네스의 체 활용
  i) 2는 소수. 2의 배수 모두 지움
  ii) 3은 소수. 3의 배수 모두 지움
  iii) 5는 소수. 5의 배수 모두 지움
  iv) 7은 소수. 7의 배수 모두 지움
  이것도 sqrt(n)까지만 알아보면 됨
  O(nloglogn)의 시간복잡도... 1번 방법보다 어마어마하게 빠르다.

  cf) 사실 모든 소수는 6n + 1, 6n + 5로 나타낼 수 있다... (n > 0)


DP 확장 - 케이스 쪼개기(2차원 배열 활용)
- 1, 2, 3 더하기 - 5
D[i][j] = i를 만드는 방법의 수. 마지막 수: j
D[i][1] = D[i-1][2] + D[i-1][3]
D[i][2] = D[i-2][1] + D[i-2][3]
D[i][3] = D[i-3][1] + D[i-3][2]

- 쉬운 계단 수
D[N][L] = 길이가 N인 계단 수. 마지막 수: L
D[N][L] = D[N-1][L-1] + D[N-1][L+1]
0, 9는 예외로 처리해야 함

- 이친수
D[i][j] = 길이가 i, 마지막 수 j인 이친수의 개수
D[i][0] = D[i-1][0] + D[i - 1][1]
D[i][1] = D[i-1][0]
D[1][0] = 0
D[1][1] = 1

또는

D[i] = 길이가 i인 이친수
마지막 수: 0 = D[i - 1]
마지막 수: 1 = D[i - 2] // 뒤에 01 박으면 그 앞은 D[i - 2]
따라서, D[i] = D[i - 1] + D[i - 2]

- 가장 긴 증가하는 부분 수열(LIS)
D[i] = max(D[j]) + 1
조건:
  j < i : 앞에 있음
  A[j] < A[i]: 증가

- 가장 긴 증가하는 부분 수열 - 4
V[i] = j 를 두는 방법?????..... >> 동영상 보자

- 가장 긴 감소하는 부분 수열
부등호만 반대로 하면 되지...

- 연속합
이전항과 더해서 최댓값을 쫒아가면 됨
즉, D[i] = max(A[i], D[i - 1] + A[i])

- 제곱수의 합
1, 2, 3 더하기 문제와 거의 유사.
맨 마지막에 L^2를 넣는다고 가정하면
D[N] = min(D[N - L^2]) + 1 (단, 1 <= L^2 <= N)
O(n * sqrt(n))

- 합분해
D[K][N] = sigma(D[K - 1][N - L])
= D[K][N - 1] + D[K - 1][N]
O(KN^2)

- 추가문제(11659번 구간의 합)
크기가 N인 배열 A. A[1], A[2], ... , A[N] (N <= 10만)
인덱스 i, j
A[i] + A[i + 1] + ... + A[j] 구할 수 있겠니?

우리가 생각한 매우 일반적인 방법은 O(N)
쿼리문제로 바뀌게 되면 누적합을 memoization 하고 구간별로 빼면 됨.

Brute Force
- for, 재귀, 순열, 비트마스크로 전수 조사
- 실제 계산량을 구해보면 컴퓨터로 충분히 구할 만 하다는 것을 느낄 수 있음.
- 문제집 N과 M 풀어보기!
