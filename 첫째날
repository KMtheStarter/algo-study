2019. 01. 08 화요일

-	동영상강의: code.plus
-	질문: question.startlink.help


-	시간복잡도 – 계산 1억회에 1초정도.
-	공간복잡도 – int 배열 1억개에 381.469MB, 얘 계산하는데 1초
-	입출력 빠르게 하기 – PDF 확인

STACK
-	괄호문제는 계단을 오르락 내리락 하는 문제로도 변환출제 가능
- 에디터문제는 링크드리스트로도 가능. 스택으로 푸는건 신박하긴 함...

QUEUE
- 큐는 한 쪽 끝에서 자료를 넣고 다른 한 쪽 끝에서 뺄 수 있는 구조
- BFS를 공부할 때 자세히... BFS는 거의 큐로 해결

DEQUE
- 덱은 양 끝에서 자료를 넣고 빼는 구조

- 시간복잡도를 고려해 볼 때, 조건문에 함수넣는건 지양하자
for (int i = 0; i < strlen(s); i++) {
  // Do something
}
-> C에서는 문자열 길이 잴 때 O(n)이므로 O(N^2)이 됨.
따라서 int len = strlen(s); 로 해놓고 사용하는 것이 바람직.

Dynamic Programming
- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
- 작은 문제의 영역이 중복될 때 중복을 제거하기 위해 DP 사용
- 분할정복(Devide & Conquer)은 작은 문제가 중복되지 않는다는 차이점 있음
- 중복문제, 문제의 정답을 작은 문제의 정답에서 구할 수 있음
- 피보나치의 Fn = Fn-1 + Fn-2과 같은 점화식
- 정답을 한 번 구했으면 정답을 어딘가에 메모해 놓는 것
- 피보나치 수열을 Top-down 방식으로 풀면 fib(n)을 위해 fib(n-1), fib(n-2)를 구하는 방식(재귀)
- Bottom-up 방식으로 풀면 fib(2)부터 차차 더해가며 구함(for문)
- 문제마다 두 가지 방법 중 쉬운게 있기 때문에 둘 다 알아야 함
- DP는 점화식 세운걸 코드로 옮기는 것이기 때문에, 코드는 사실상 별로 중요치 않다.

1로 만들기 (https://www.acmicpc.net/problem/1463)
- D[N/3]+1
- D[N/2]+1
- D[N-1]+1 중 최솟값 찾기

2xN 타일링 (https://www.acmicpc.net/problem/11726)
- 가장 오른쪽에 어떤 모양의 타일이 올 수 있는가?
- 세로 하나 -> D[n-1]
- 가로 둘 -> D[n-2]
따라서, D[n] = D[n-1] + D[n-2]

1, 2, 3 더하기 (https://www.acmicpc.net/problem/9095)
- 가장 마지막에 1, 2, 3 올 수 있음
- 즉, D[n] = D[n-1] + D[n-2] + D[n-3]
- D[0] = 1이다. 1, 2, 3을 사용하지 않은 공집합의 경우.

카드 구매하기 (https://www.acmicpc.net/problem/11052)
- D[N] = max(D[i], P[i] + D[N-i])
- 문제의 수가 N, 문제 1개를 푸는 시간이 N이므로 O(n^2)
