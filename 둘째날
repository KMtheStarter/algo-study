2019. 01. 10 목요일

Mathematics
- 소수를 사용하는건 최대한 지양하자.
- 만약 써야한다면 double 자료형 사용. float은 덜 정확

- (6%3 ‒ 5%3) % 3 = (0 ‒ 2) % 3 = -2 % 3 = ?에서 C++의 경우 -2를 출력함
따라서, ((6%3 ‒ 5%3) + 3) % 3 을 하면 됨. (양수인지 음수인지 모르면 분모를 더하기)

- 최대공약수(GCD)를 구할 때, 
a를 b로 나눈 나머지를 r이라고 하면 GCD(a, b) = GCD(b, r) - 유클리드 호제법
재귀로 풀어내면 O(logN)의 시간복잡도를 가진다.
-> 분수의 형태로 나와 약분을 할 때나 진짜 수학문제를 풀 때 사용함.

- 최소공배수(LCM)을 구할 때,
GCD * LCM = A * B 인것을 활용하면 됨.

- 소수를 구하는 문제
1. 어떤 수 x가 소수?
// 정의를 활용한 방법
bool prime(int n) {
  if (n < 2) {
    return false;
  }
  for (int i=2; i<=n-1; i++) {
    if (n % i == 0) {
      return false;
    }
  }
  return true;
}
-> 정의 + 범위 쪼개기, 즉 i <= n/2; 로 해도 좋다.
-> 더 나아가면 i < =sqrt(n) -> i * i <= n; 으로 가는게 더 좋다. 이유는 자명함...

2. 1~N 범위의 모든 소수?
1.의 방법을 활용하면 O(n*sqrt(n))

-> 더 나은방법? 에라토스테네스의 체 활용
i) 2는 소수. 2의 배수 모두 지움
ii) 3은 소수. 3의 배수 모두 지움
iii) 5는 소수. 5의 배수 모두 지움
iv) 7은 소수. 7의 배수 모두 지움
이것도 sqrt(n)까지만 알아보면 됨
O(nloglogn)의 시간복잡도... 1번 방법보다 어마어마하게 빠르다.

cf) 사실 모든 소수는 6n+1, 6n+5로 나타낼 수 있다... (n > 0)
