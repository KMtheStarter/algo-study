2019. 01. 17

Brute Force - 순열
- 순열을 사전순으로 나열했을 때, 사전순으로 다음에 오는 순열과 이전에 오는 순열 찾기
  => C++의 algorithm에는 이미 next_permutation과 prev_permutation이 존재하기 때문에 사용하면 됨
     Python의 itertools에도 next_permutation 존재
- 어떤 순열의 마지막 순열을 구하면, 그 다음 순열을 구할 수 있다.
ex) 7 2 3 6 5 3 1의 경우 7 2 3 / 6 5 4 1이라는 순열의 마지막 순열임을 알 수 있음.
    3 다음으로 뒤에서 큰 수는 4이므로, 위치를 바꾸면 7 2 4 / 6 5 3 1 이고, 뒷자리를 뒤집으면
    바로 다음 순열인 7 2 4 / 1 3 5 6 이 됨.
- 모든 순열을 구하는 시간: O(N * N!)
  => 따라서, 시간 상 순열을 전부 구해야하는 문제면 N이 10이하로 주어질 것임
- 순열 문제에선 do-while을 많이 사용.

외판원 순회2
- 영어로 Travelling Salesman Problem(TSP)
- 모든 도시를 방문하면서 한 번 방문한 도시는 다시 가지 않으므로 순열문제!
- 따라서 N <= 10 이어야 풀 수 있음


Brute Force - 재귀
1, 2, 3 더하기
- 정답을 찾은 경우 (sum == goal, 1 리턴),
  불가능한 경우 (sum > goal, 0 리턴),
  다음 경우 호출
  1을 사용: go(count + 1, sum + 1, goal)
  2를 사용: go(count + 1, sum + 2, goal)
  3을 사용: go(count + 1, sum + 3, goal) -> 세 수 합 리턴        이 필요.
- DP로 푸는게 사실 더 좋음. O(3^N) DP로는 O(N)

암호만들기
- 정답을 찾은 경우 (n == password의 길이),
  불가능한 경우 (i >= alpha의 크기),
  다음 경우 호출
  i번째 알파벳 사용: go(n, alpha, password + alpha[i], i + 1)
  i번째 알파벳 미사용: go(n, alpha, password, i + 1)
  
부분집합의 합
- 총 부분집합의 개수가 2^20 이므로 계산 가능
- i번째 포함: go(index + 1, sum + A[index])
  i번째 포함x: go(index + 1, sum)
  
퇴사
- 정답을 찾은 경우 (day == n)
   불가능한 경우 (day > n)
   상담을 함: go(day + i[day], sum + p[day])
   상담을 안함: go(day + 1, sum)
- DP로도 푸는게 가능하다. 사진 참고, 사진의 코드에 memoization 추가하면 됨

테트로미노
- 한 점에서 나머지 블록으로 방문한다고 생각하고 재귀로 해결
- ㅗ모양의 블록은 예외. for문으로 4방향 돌린거 생각해서 해결

두 동전
- 10번보다 많이 누르면 -1을 출력하므로 4^10 = 1048576가지. 연산 가능
- 동전들의 위치, 버튼을 누른 횟수가 중요

에너지 모으기
- 최대 경우의 수는 8! ((N - 2)!)


Backtracking
- 브루트포스 중 가지치기 방법
- 이 경우로 가면 답이 없겠다 싶으면 그만 두는 방법
- 어떻게 정지시키냐에 따른 아이디어가 모두 달라서 시간에 대한 개인차가 큼
- 요즘엔 출제자체를 잘 안함


Bitmask
- 집합을 정수로 나타낼 수 있다는 것
- 1 << 5 = 32 : 1을 오른쪽으로 5번 밀면 100000(2)가 됨
- {1, 3, 4, 5, 9} = 570
  9 8 7 6 5 4 3 2 1 0
  1 0 0 0 1 1 1 0 1 0(2) = 570

cf> 지역변수보다 전역변수쓰는게 편하고 좋다...
    지역변수는 stack에 쌓이기 때문에 제한이 많음 ㅠ
    전역변수는 heap에 쓰여짐
    전역변수는 자동으로 초기화도 됨
